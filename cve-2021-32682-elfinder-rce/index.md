# CVE-2021-32682 elFinder RCE 简单分析


# 简介  

elFinder 是一个开源的 web 文件管理器，使用 jQuery UI 用 Ja​​vaScript 编写。Creation 的灵感来自于 Mac OS X 操作系统中使用的 Finder 程序的简单性和便利性。

# 漏洞描述  

该漏洞源于,在创建新的zip存档时，没有对`name`参数进行严格的过滤，导致参数被带入`prox_open`中执行，造成命令注入

# 影响版本  

```
elFinder <= 2.1.58
```

# 环境搭建  

下载地址：
    https://github.com/Studio-42/elFinder

下载完成后，重命名`/php/connector.minimal.php-dist`为`/php/connector.minimal.php`
然后在浏览器中加载运行`/elfinder.src.html`即可

![1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/ef2d0fc3-a59e-c529-02ae-3dd78993291c.png)

# 漏洞分析

源码地址：
    https://github.com/Studio-42/elFinder/releases/tag/2.1.58

得知是通过存档功能，传递`name`参数造成命令注入，然后进行抓包

![2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/511ee04e-a66e-db36-990d-be771e9102c1.png)

可以看出是在`connector.minimal.php`文件中进行操作

在`connector.minimal.php`文件中发现，包含文件`autoload.php`

![3.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/ee72929f-610d-0350-5a05-a93053d93c0e.png)

在`autoload.php`中，不确定在那个文件，不过通过名字大概率可以在`elFinderVolumeLocalFileSystem.class.php`和`elFinder.class.php`中可以找到

![4.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/54afde8b-1628-7bbd-70db-48fb0f27f9da.png)

先进入`elFinderVolumeLocalFileSystem.class.php`中，通过抓包得知`cmd=archive`，可能有archive函数

![5.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/29f3c9ef-b478-2a5c-eeff-7806e107be90.png)

发现果然有，跟进`makeArchive`函数

![6.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/e4c4ead3-7f5c-e1aa-7a42-0ed8fff0ba76.png)

可以看出参数确实是传到`makeArchive`，但是不是通过`_archive`传进来的
接下来在`elFinder.class.php`中尝试

![7.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/803149e1-031e-11b7-672b-c9129ad16d80.png)

先对name参数进行isset判断，然后传入`archive`函数中，继续跟进

![8.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/fc9a8b56-cce6-ee22-3804-9e723fb0f183.png)

`$name`先进行了正则转换后进行了字符串替换，然后先传入到`uniqueName`中，后传入到`remoteArchive`中，先跟进到`uniqueName`中

![9.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/ad60937c-ff82-9837-d684-19a534faa157.png)

可以看出是对`$name`进行了一些转换替换，最后返回`$name`值
接下来返回上一步，跟进到`remoteArchive`中

![10.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/c40740de-e656-c463-496c-5bd162f8bf91.png)

看见参数传入到`makeArchive`函数中，继续跟进

![6.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/e4c4ead3-7f5c-e1aa-7a42-0ed8fff0ba76.png)

到这里参数通过`escapeshellarg()`进行转义，然后拼接其它参数赋值给`$cmd`，然后进入到`procExec`函数中

![11.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/0f47cf57-f334-bc06-efb1-5390cbc63ac0.png)

可以看见`$cmd`被作为参数，放入到`proc_open`中执行命令
`proc_open`命令详解如下：

![12.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/21be8c43-0a2c-0bf2-ab24-ef4fc8f5f81a.png)

自此整个流程分析完成，虽然中间对参数进行了正则和替换的过滤操作，但是因为程序会将`name`参数值解析为标志（`--foo=bar`），可以通过`zip`的`-TT`指定要运行的测试命令，如：`-TmTT="$(id>out.txt)foooo"`
通过测试得到，参数在传入到`proc_open`中执行命令前，其值为`"zip -r9 -q 'a1.zip' './a.zip'"`，所以我们可以构造成以下命令`"zip -r9 -q '-TmTT="$(id>out.txt)foooo".zip' './a.txt'"`，执行`id`命令并将结果输出到`out.txt`中

![13.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/7b168d71-16fc-c643-664b-4b517f6da67c.png)

# 参考链接

1. https://github.com/Studio-42/elFinder/commit/a106c350b7dfe666a81d6b576816db9fe0899b17
2. https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities
3. https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt
