# CVE-2022-22980 Spring Data MongoDB SpEL表达式注入


# 前言

昨天在推特上看到threedr3am师傅发的Spring Data MongoDB SpEL的[环境](https://github.com/threedr3am/learnjavabug/tree/master/spring/spring-data-mongodb-spel-CVE-2022-22980)，然后就自己去手动分析了一波，这里用的版本是Spring Data MongoDB 3.3.4

漏洞的原因是当使用`@Query`或`@Aggregation`注解[进行数据库查询](https://spring.io/blog/2014/07/15/spel-support-in-spring-data-jpa-query-definitions)，且使用了占位符获取参数导致的Spel表达式注入

![0.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/220c868f-d07f-bb15-e722-5a6b8ea69fd2.png)

# 漏洞分析

在[diif](https://github.com/spring-projects/spring-data-mongodb/commit/7c5ac764b343d45e5d0abbaba4e82395b471b4c4?diff=split)上可以看到漏洞触发的点

![1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/23c5607a-5851-3422-b057-5513b42d0383.png)

在`org.springframework.data.mongodb.util.json.ParameterBindingJsonReader#bindableValueFor`中进行绑定参数时触发漏洞，直接在327行打个断点调试，此时`expression`的值就是构造好的payload，但此时并不会触发漏洞，会在下一次再到这个地方时才会触发漏洞，这里跟进到`this.evaluateExpression`中看一下

![2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/296211f0-fc11-a664-0b7f-9da195ce3c3f.png)

此时`this.expressionEvaluator`的值为`ParameterBindingDocumentCodec`，此时会进入到`ParameterBindingDocumentCodec`中对`expression`进行处理，最后会返回一个空的对象

![3.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/d3eaeb62-ac76-a56b-8285-1add4b14e3cf.png)

![4.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/61c0cdf7-4784-82aa-cfa5-bf8bc156d668.png)

接下来比较了在同一个地方两个的堆栈，发现是在`org.springframework.data.mongodb.repository.query.StringBasedMongoQuery#createQuery`中先进入到`getBindingContext`进行了参数绑定，看到此时传入的`codec`就是`ParameterBindingDocumentCodec`导致第一次并没有触发漏洞，然后绑定参数后在进入到`decode`中最后会再次进入`bindableValueFor`中

![5.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/91fb3e40-ef0f-8277-9bb6-ad97f68b7924.png)

![6.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/58e8580e-fa84-4b89-c6bc-c86112db5615.png)

先来看一下第一次进行参数绑定时进行了什么操作，在`org.springframework.data.mongodb.util.json.ParameterBindingJsonReader#readBsonType`中，通过switch判断token的Type属性，进入到UNQUOTED_STRING中，在这里进行`setCurrentName`操作，该值是在`bindableValueFor`中通过一系列操作后获得，其为**实体类中的id参数**

![7.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/be659d5c-ab0b-24e6-2d32-b97a843fc320.png)

![8.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/8173b86c-6065-e8ff-8fc0-0ea39c11aa27.png)

接着继续往下走，会经过很多对value值进行equals的对比，此时value是`:#{?0}`，肯定是false的，最后进入到`bindableValueFor`中，首先是先把值传给了tokenValue，然后先后对其进行了`PARAMETER_BINDING_PATTERN`和`EXPRESSION_BINDING_PATTERN`规则匹配表达式，然后取出值交给binding，在通过substring取出占位符`?0`，接下来通过for循环将一开始传进来的payload和占位符进行替换，然后执行`this.evaluateExpression`，因为同时传入的`codec`，只是返回了一个空的Object实例，最后将value和type进行set后返回bindableValue，这里感觉就是先对实体类的id参数进行了绑定

![9.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/d41fc3c8-ca45-f9c2-1a0c-ed612407f37e.png)

![10.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/b285d5cb-5b20-aee0-7828-b8145bfa3199.png)

```java
private static final Pattern PARAMETER_ONLY_BINDING_PATTERN = Pattern.compile("^\\(\\d+)$");
private static final Pattern PARAMETER_BINDING_PATTERN = Pattern.compile("\\?(\\d+");
private static final Pattern EXPRESSION_BINDING_PATTERN = Pattern.compile("[\\?:#\\{.*\\}");
```

接着进行`this.getBindingContext`后，会进入到`decode`中，最后进行一样的操作，此时`this.expressionEvaluator`为`DefaultSpELExpressionEvaluator`，最后执行getValue触发SpEl表达式注入

![6.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/58e8580e-fa84-4b89-c6bc-c86112db5615.png)

![11.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/9089cf15-9197-50ea-1571-d0b0d74f0c9b.png)

![12.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/2375dedb-a774-36be-fe9a-09c01d7945d4.png)


# 漏洞防御

这里引入的是Spring Data MongoDB 3.3.4

在新版本中额外增加了一个规则匹配表达式，并对`binding`也就是`:#{?0}`进行匹配，然后将传进来的payload放入到`innerSpelVariables`的键值对里，key为特殊字符，最后和`binding`一起传入到`this.evaluateExpression`中

![13.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/42f1c8c6-41d1-130b-c2e2-ddee12e64ebd.png)

```java
private static final Pattern SPEL_PARAMETER_BINDING_PATTERN = Pattern.compile("('\\?(\\d+)'|\\?(\\d+))");
```

其中进行了三元运算符判断，判断的是`this.expressionEvaluator`是否为`EvaluationContextExpressionEvaluator`的实例，然后会是false进入到`evaluate`，此时传进来的是键值对中的key`#__QVar0`然后无法触发SpEL表达式注入

```java
public Object evaluateExpression(String expressionString, Map<String, Object>variables) {
    return this.expressionEvaluator instanceof EvaluationContextExpressionEvaluator ? ((EvaluationContextExpressionEvaluator)this.expressionEvaluator).evaluateExpression(expressionString, variables) : this.expressionEvaluator.evaluate(expressionString);
}
```

![14.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2513662/570f6384-0030-9822-f56f-3b7381c5ee25.png)

# 参考链接

1. https://github.com/threedr3am/learnjavabug/tree/master/spring/spring-data-mongodb-spel-CVE-2022-22980
2. https://github.com/spring-projects/spring-data-mongodb/commit/7c5ac764b343d45e5d0abbaba4e82395b471b4c4?diff=split


